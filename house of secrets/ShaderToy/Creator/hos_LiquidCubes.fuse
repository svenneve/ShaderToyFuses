--[[

OpenCL Squigly.

This is a ShaderToy conversion of Liquid Cubes by ShaderToy user Gijs.
https://www.shadertoy.com/view/MtBSWRn

Conversion done by S.Neve / House of Secrets.
]]--

FuRegisterClass("hos_LiquidCubes", CT_SourceTool, {
    REGS_Name = "Liquid Cubes",
	REGS_Category = "House of Secrets\\ShaderToy\\Creator",
	REGS_OpIconString = "STlq",
	REGS_OpDescription = "OpenCL Liquid Cubes Fuse",

	REG_Source_GlobalCtrls = true,
	REG_Source_SizeCtrls = true,
	REG_Source_AspectCtrls = true,
	REG_Source_DepthCtrls = true,
	REG_SupportsDoD = true,
	REG_NoPreCalcProcess = true,
	})


clsource =
[[
float sdPlane( float3 p )
{
	return p.y;
}

float sdBox( float3 p, float3 b )
{
  float3 d = fabs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

//----------------------------------------------------------------------

float opS( float d1, float d2 )
{
    return max(-d2,d1);
}

float2 opU( float2 d1, float2 d2 )
{
	return (d1.x<d2.x) ? d1 : d2;
}

float3 opRep( float3 p, float3 c )
{
    return fmod(p,c)-0.5*c;
}

float3 opRepXZ( float3 p, float3 c )
{
    return (float3)(fmod(p.x,c.x)-0.5*c.x, p.y, fmod(p.z,c.z)-0.5*c.z);
}

// polynomial smooth min (k = 0.1);
float smin( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return mix( b, a, h ) - k*h*(1.0-h);
}

// exponential smooth min (k = 32);
float smin2( float a, float b, float k )
{
    float res = exp( -k*a ) + exp( -k*b );
    return -log( res )/k;
}

float3 opTwist( float3 p )
{
    float  c = cos(10.0*p.y+10.0);
    float  s = sin(10.0*p.y+10.0);
    //mat2   m = mat2(c,-s,s,c);
    //return (float3)(m*p.xz,p.y);
    return (float3)(p.xz,p.y);
}

float3 rX( float3 p, float a) {
	float c,s;float3 q=p;
	c = cos(a); s = sin(a);
	return (float3)(p.x, c * q.y - s * q.z, s * q.y + c * q.z);
}

float3 rY( float3 p, float a) {
	float c,s;float3 q=p;
	c = cos(a); s = sin(a);
	return (float3)(c * q.x + s * q.z, p.y, -s * q.x + c * q.z);
}

//----------------------------------------------------------------------

float rand(float2 co){
    float i;
    return fract(sin(dot(co.xy ,(float2)(12.9898,78.233))) * 43758.5453, &i);
}

float2 map( float3 pos) {
    float2 res = (float2)(sdPlane(pos), 1.0);
    
    // bledng cubes by groups of 9
    float gap = 1.2;
	
    float3 cubeSize = convert_float3(0.5);
    for(float i=-1.; i<=1.; i+=1.) {
        for(float j=-1.; j<=1.; j+=1.) {
            float3 p = opRepXZ(pos, (float3)(gap, 0., gap))+(float3)(i*gap, 0., j*gap);
//            float3 p = pos+(float3)(i*gap, 0., j*gap);
            float rotX = iGlobalTime+pos.x*0.3;
	        float rotY = iGlobalTime+pos.z*0.3;
            float3 p2 = rY(rX(p, rotX), rotY);
            
            float dst = sdBox(p2, cubeSize);
            
            // smooth min
            float a = res.x;
            float b = dst;
            // blending power : 0. to 1.
            float k = .5;
            float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
            
		    res = (float2)(mix( b, a, h ) - k*h*(1.0-h), 3.0);
        }
    }

    return res;
}

float2 castRay( float3 ro,  float3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<50; i++ )
    {
	    float2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return float2( t, m );
}


float softshadow(  float3 ro,  float3 rd,  float mint,  float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

float3 calcNormal(  float3 pos )
{
	float3 eps = ( 0.001, 0.0, 0.0 );
	float3 nor = (
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

float calcAO(  float3 pos,  float3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        float3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}




float3 render(float3 ro, float3 rd )
{ 
    float3 col = (0.8, 0.9, 1.0);
    float2 res = castRay(ro,rd);
    float t = res.x;
	float m = res.y;
    if( m>-0.5 )
    {
        float3 pos = ro + t*rd;
        float3 nor = calcNormal( pos );
        float3 ref = reflect( rd, nor );
        
        // material        
		col = 0.45 + 0.3*sin( (float3)(0.05,0.08,0.10)*(m-1.0) );
		
        if( m<1.5 )
        {
            
            float f = fmod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);
            col = 0.4 + 0.1*f*(float3)(1.0);
        }

        // lighitng        
        float occ = calcAO( pos, nor );
		float3  lig = normalize( (float3)(-0.6, 0.7, -0.5) );
		float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
        float bac = clamp( dot( nor, normalize((float3)(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
        float dom = smoothstep( -0.1, 0.1, ref.y );
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
		float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
        
//        dif *= softshadow( pos, lig, 0.02, 2.5 );
//        dom *= softshadow( pos, ref, 0.02, 2.5 );

		float3 brdf = convert_float3(0.0);
        brdf += 1.20*dif*(float3)(1.00,0.90,0.60);
		brdf += 1.20*spe*(float3)(1.00,0.90,0.60)*dif;
        brdf += 0.30*amb*(float3)(0.50,0.70,1.00)*occ;
        brdf += 0.40*dom*(float3)(0.50,0.70,1.00)*occ;
        brdf += 0.30*bac*(float3)(0.25,0.25,0.25)*occ;
        brdf += 0.40*fre*(float3)(1.00,1.00,1.00)*occ;
		brdf += 0.02;
		col = col*brdf;

    	col = mix( col, (float3)(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );

    }

	return (float3)( clamp(col,0.0,1.0) );
}

mat3 setCamera( float3 ro,  float3 ta, float cr )
{
	float3 cw = normalize(ta-ro);
	float3 cp = float3(sin(cr), cos(cr),0.0);
	float3 cu = normalize( cross(cw,cp) );
	float3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

kernel void LiquidCubes(FuWriteImage_t dst,
                            const int2 size,
                            const float iGlobalTime)
{
    const int2 ipos = (int2)(get_global_id(1), get_global_id(0));
    float2 fragCoord = convert_float(ipos);
    float2 iResolution = convert_float(size);
    float2 iMouse = (0., 0.);
    
	float2 q = fragCoord.xy/iResolution.xy;
    float2 p = -1.0+2.0*q;
	p.x *= iResolution.x/iResolution.y;
    float2 mo = iMouse.xy/iResolution.xy;
		 
	float time = 15.0 + iGlobalTime;

	// camera	
//	float3 ro = ( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );
	float3 ro = ( 0., 8.0, 0.5 + 3.5);
	float3 ta = ( -0.5, -0.4, 0.5 );
    
	// camera-to-world transformation
    mat3 ca = setCamera( ro, ta, 0.0 );
    
    // ray direction
	float3 rd = ca * normalize( (p.xy,2.0) );

    // render	
    float3 col = render( ro, rd );

	col = pow( col, convert_float3(0.4545) );

    //fragColor=vec4( col, 1.0 );
    FuWriteImagef(dst, ipos, size, (float4)( col, 1.0 ));
}
]]

function Create()
	InTimeMultiplier = self:AddInput("Time Multiplier", "TimeMultiplier", {
		LINKID_DataType = "Number",
		INPID_InputControl = "SliderControl",
		INP_Default = 0.0,
		})
	OutImage = self:AddOutput("Output", "Output", {
		LINKID_DataType = "Image",
		LINK_Main = 1,
		})				

	mgr = OCLManager()
	if mgr then
		prog = mgr:BuildCachedProgram(self.RegNode, clsource)
	end
end

-- function OnAddToFlow()
	-- mgr = OCLManager()
	-- if mgr then
		-- local path = string.sub(debug.getinfo(1).source, 2)
		-- prog = mgr:BuildCachedProgram("SourceTemplate", path, clsource)
	-- end
-- end

function Process(req)
    local timemultiplier = InTimeMultiplier:GetValue(req).Value
    local _time = req.Time * timemultiplier;
    
	if mgr.SupportsImages == false then
		SourceDepth = 8			-- force to float32
	end

	local realwidth = Width;
	local realheight = Height;

	-- We'll handle proxy ourselves
	Width = Width / Scale
	Height = Height / Scale
	Scale = 1

	local imgattrs = {
		IMG_Document = self.Comp,
		IMG_Width = Width,
		IMG_Height = Height,
		IMG_XScale = XAspect,
		IMG_YScale = YAspect,
		IMAT_OriginalWidth = realwidth,
		IMAT_OriginalHeight = realheight,
		IMG_Quality = not req:IsQuick(),
		IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
		}
	
	if not req:IsStampOnly() then
		imgattrs.IMG_ProxyScale = 1
	end
	
	if SourceDepth ~= 0 then
		imgattrs.IMG_Depth = SourceDepth
	end
	
	local img = Image(imgattrs)
	local out

	if req:IsPreCalc() then
		out = img
	elseif prog and img then
		local climg = prog:CreateImage(img, "readwrite")
		if climg then
			-- create image
			local kernel = prog:CreateKernel("LiquidCubes")

			if kernel then
				prog:SetArg(kernel, 0, climg)
				prog:SetArgInt(kernel, 1, Width, Height)
                prog:SetArg(kernel, 2, _time)
				prog:SetWorkgroupSize(64)


                -- if prog:Download(climg, img) then
                    -- out = img
                -- end
                prog:RunKernel(kernel)
				if self.Status then
					prog:Download(climg, img)
					out = img
				end
            end
			if climg then
				climg:ReleaseCLObject()
			end
		end
	end


	local te = TimeExtent()
	if timemultiplier > 0.0 then
	te = TimeExtent(req.Time, req.Time, TIME_UNDEFINED)
	end

	req:SetOutputData(OutImage, out, te)
    -- OutImage:Set(req, out)
end
